<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Layout Designer – Grid & Drag (m/cm)</title>
  <!-- Tailwind Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React & ReactDOM en producción -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel con preset React -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body, #root { height: 100%; }
    kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="react">
    const { useEffect, useMemo, useRef, useState } = React;

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const uid = () => Math.random().toString(36).slice(2, 9);

    const DEFAULT_SCALE_PX_PER_M = 120;
    const DEFAULT_GRID_STEP_M = 0.1;
    const UNIT_META = {
      m: { label: "m", toBase: (v) => v, fromBase: (v) => v },
      cm: { label: "cm", toBase: (v) => v / 100, fromBase: (v) => v * 100 },
    };
    const SHAPE_TYPES = { rect: { label: "Rectangle" }, circle: { label: "Circle" } };

    function Section({ title, children }) {
      return (
        <div className="mb-4 p-3 rounded-2xl border bg-white shadow-sm">
          <div className="font-semibold text-gray-800">{title}</div>
          <div className="mt-3">{children}</div>
        </div>
      );
    }

    function formatLen(v) {
      const isIntish = Math.abs(v - Math.round(v)) < 1e-6;
      return isIntish ? `${Math.round(v)}` : v.toFixed(2);
    }

    function Shape({ shape, selected, unitLabel, sizePxToUnit, onMouseDown }) {
      const { type, x, y, w, h, fill, opacity, label } = shape;
      const dimsText = `${formatLen(sizePxToUnit(w))} ${unitLabel} × ${formatLen(sizePxToUnit(h))} ${unitLabel}`;

      if (type === "rect") {
        return (
          <div
            className={`absolute group select-none ${selected ? "ring-2 ring-indigo-500" : "ring-1 ring-gray-300"}`}
            style={{ left: x, top: y, width: w, height: h, backgroundColor: fill, opacity, borderRadius: 8 }}
            onMouseDown={(e) => onMouseDown(e, "move")}
          >
            <div className="absolute -top-7 left-0 px-2 py-0.5 text-xs rounded-md bg-white/90 border shadow">
              <div className="font-medium">{label}</div>
              <div className="text-[10px] text-gray-600">{dimsText}</div>
            </div>
            <div
              className="absolute -bottom-2 -right-2 h-4 w-4 rounded-full bg-white border shadow cursor-nwse-resize opacity-0 group-hover:opacity-100"
              onMouseDown={(e) => onMouseDown(e, "resize")}
              title="Redimensionar"
            />
          </div>
        );
      }
      if (type === "circle") {
        const size = Math.min(w, h);
        return (
          <div
            className={`absolute group select-none ${selected ? "ring-2 ring-indigo-500" : "ring-1 ring-gray-300"}`}
            style={{ left: x, top: y, width: size, height: size, backgroundColor: fill, opacity, borderRadius: "9999px" }}
            onMouseDown={(e) => onMouseDown(e, "move")}
          >
            <div className="absolute -top-7 left-0 px-2 py-0.5 text-xs rounded-md bg-white/90 border shadow">
              <div className="font-medium">{label}</div>
              <div className="text-[10px] text-gray-600">Ø {formatLen(sizePxToUnit(size))} {unitLabel}</div>
            </div>
            <div
              className="absolute -bottom-2 -right-2 h-4 w-4 rounded-full bg-white border shadow cursor-nwse-resize opacity-0 group-hover:opacity-100"
              onMouseDown={(e) => onMouseDown(e, "resize")}
              title="Redimensionar"
            />
          </div>
        );
      }
      return null;
    }

    function App() {
      const [unit, setUnit] = useState("m");
      const [scalePxPerM, setScalePxPerM] = useState(DEFAULT_SCALE_PX_PER_M);
      const [gridStepM, setGridStepM] = useState(DEFAULT_GRID_STEP_M);
      const [snap, setSnap] = useState(true);

      const [shapes, setShapes] = useState([]);
      const [selectedId, setSelectedId] = useState(null);

      const [pan, setPan] = useState({ x: 0, y: 0 });
      const panRef = useRef(pan);
      useEffect(() => { panRef.current = pan; }, [pan]);

      const canvasRef = useRef(null);

      const unitLabel = UNIT_META[unit].label;
      const unitToMeters = UNIT_META[unit].toBase;
      const metersToUnit = UNIT_META[unit].fromBase;

      const gridStepInPx = gridStepM * scalePxPerM;

      const sizeUnitToPx = (valInUnit) => unitToMeters(valInUnit) * scalePxPerM;
      const sizePxToUnit = (px) => metersToUnit(px / scalePxPerM);
      const snapPx = (px) => (snap ? Math.round(px / gridStepInPx) * gridStepInPx : px);

      const addShape = (type) => {
        const id = uid();
        const baseWUnit = unit === "m" ? 1 : 100;
        const baseHUnit = unit === "m" ? 0.6 : 60;
        const newShape = {
          id,
          type,
          x: 100,
          y: 100,
          w: sizeUnitToPx(baseWUnit),
          h: sizeUnitToPx(baseHUnit),
          fill: "#4f46e5",
          opacity: 0.85,
          label: type === "rect" ? "Mesa" : "Pilar",
          rotation: 0,
        };
        setShapes((s) => [...s, newShape]);
        setSelectedId(id);
      };

      const updateShape = (id, patch) => {
        setShapes((s) => s.map((sh) => (sh.id === id ? { ...sh, ...patch } : sh)));
      };

      const deleteSelected = () => {
        if (!selectedId) return;
        setShapes((s) => s.filter((sh) => sh.id !== selectedId));
        setSelectedId(null);
      };

      const dragState = useRef({ dragging: false, id: null, offsetX: 0, offsetY: 0, mode: "move" });

      const onMouseDownShape = (e, id, mode = "move") => {
        e.stopPropagation();
        const rect = canvasRef.current.getBoundingClientRect();
        const sh = shapes.find((s) => s.id === id);
        const mouseX = e.clientX - rect.left - pan.x;
        const mouseY = e.clientY - rect.top - pan.y;
        dragState.current = { dragging: true, id, mode, offsetX: mouseX - sh.x, offsetY: mouseY - sh.y };
        setSelectedId(id);
      };

      const onMouseDownCanvas = (e) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
          const rect = canvasRef.current.getBoundingClientRect();
          const start = { x: e.clientX - rect.left, y: e.clientY - rect.top };
          const startPan = { ...panRef.current };
          const onMove = (ev) => setPan({ x: startPan.x + (ev.clientX - rect.left - start.x), y: startPan.y + (ev.clientY - rect.top - start.y) });
          const onUp = () => { window.removeEventListener("mousemove", onMove); window.removeEventListener("mouseup", onUp); };
          window.addEventListener("mousemove", onMove); window.addEventListener("mouseup", onUp);
          return;
        }
        setSelectedId(null);
      };

      useEffect(() => {
        const onMove = (e) => {
          if (!dragState.current.dragging) return;
          const rect = canvasRef.current.getBoundingClientRect();
          const mouseX = e.clientX - rect.left - panRef.current.x;
          const mouseY = e.clientY - rect.top - panRef.current.y;
          const { id, offsetX, offsetY, mode } = dragState.current;
          setShapes((prev) =>
            prev.map((sh) => {
              if (sh.id !== id) return sh;
              if (mode === "move") {
                const nx = snapPx(mouseX - offsetX);
                const ny = snapPx(mouseY - offsetY);
                return { ...sh, x: nx, y: ny };
              } else if (mode === "resize") {
                const nw = clamp(snapPx(mouseX - sh.x), 10, 5000);
                const nh = clamp(snapPx(mouseY - sh.y), 10, 5000);
                return { ...sh, w: nw, h: nh };
              }
              return sh;
            })
          );
        };
        const onUp = () => {
          dragState.current.dragging = false;
          dragState.current.id = null;
        };
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);
        return () => {
          window.removeEventListener("mousemove", onMove);
          window.removeEventListener("mouseup", onUp);
        };
      }, [gridStepInPx]);

      const gridBackground = useMemo(() => {
        const s = gridStepInPx; const big = s * 5;
        return {
          backgroundImage: `
            linear-gradient(to right, rgba(0,0,0,0.08) 1px, transparent 1px),
            linear-gradient(to bottom, rgba(0,0,0,0.08) 1px, transparent 1px),
            linear-gradient(to right, rgba(0,0,0,0.18) 1px, transparent 1px),
            linear-gradient(to bottom, rgba(0,0,0,0.18) 1px, transparent 1px)
          `,
          backgroundSize: `${s}px ${s}px, ${s}px ${s}px, ${big}px ${big}px, ${big}px ${big}px`,
          backgroundPosition: `${pan.x}px ${pan.y}px, ${pan.x}px ${pan.y}px, ${pan.x}px ${pan.y}px, ${pan.x}px ${pan.y}px`,
        };
      }, [gridStepInPx, pan]);

      const selected = shapes.find((s) => s.id === selectedId) || null;

      return (
        <div className="h-screen w-full bg-gray-50 text-gray-900">
          <div className="flex items-center justify-between px-4 py-3 border-b bg-white sticky top-0 z-10">
            <div className="flex items-center gap-2">
              <div className="text-lg font-semibold">Layout Designer</div>
              <div className="text-xs text-gray-500">(arrastra, suelta y ajusta escala real)</div>
            </div>
            <div className="flex items-center gap-2">
              <button onClick={() => addShape("rect")} className="px-3 py-2 rounded-xl bg-gray-900 text-white hover:bg-black shadow">+ Rectángulo</button>
              <button onClick={() => addShape("circle")} className="px-3 py-2 rounded-xl bg-gray-900 text-white hover:bg-black shadow">+ Círculo</button>
            </div>
          </div>

          <div className="grid grid-cols-[300px_1fr] h-[calc(100vh-56px)]">
            <div className="p-3 border-r bg-white overflow-y-auto">
              <Section title="Unidades & Escala">
                <div className="flex items-center gap-2">
                  <label className={`px-3 py-1 rounded-full border cursor-pointer ${unit === "m" ? "bg-gray-900 text-white" : "bg-white"}`}>
                    <input type="radio" name="unit" className="hidden" checked={unit === "m"} onChange={() => setUnit("m")} />
                    Metros
                  </label>
                  <label className={`px-3 py-1 rounded-full border cursor-pointer ${unit === "cm" ? "bg-gray-900 text-white" : "bg-white"}`}>
                    <input type="radio" name="unit" className="hidden" checked={unit === "cm"} onChange={() => setUnit("cm")} />
                    Centímetros
                  </label>
                </div>
                <div className="mt-3 text-sm">
                  <label className="block text-gray-500">Escala (1 m = px)</label>
                  <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2" min={20} max={800}
                         value={scalePxPerM}
                         onChange={(e) => setScalePxPerM(clamp(Number(e.target.value), 10, 2000))} />
                </div>
                <div className="mt-3 text-sm">
                  <label className="block text-gray-500">Cuadrícula cada</label>
                  <div className="flex items-center gap-2">
                    <input type="number" className="mt-1 w-24 rounded-xl border px-3 py-2"
                           step={unit === "m" ? 0.1 : 1} min={unit === "m" ? 0.05 : 5}
                           value={UNIT_META[unit].fromBase(gridStepM)}
                           onChange={(e) => setGridStepM(UNIT_META[unit].toBase(Number(e.target.value)))} />
                    <span className="text-gray-600">{UNIT_META[unit].label}</span>
                  </div>
                </div>
                <div className="mt-3 flex items-center justify-between">
                  <label className="text-sm text-gray-700">Ajustar a cuadrícula</label>
                  <input type="checkbox" checked={snap} onChange={(e) => setSnap(e.target.checked)} />
                </div>
              </Section>

              <Section title="Figura seleccionada">
                {!selected ? (
                  <div className="text-sm text-gray-500">Selecciona una figura para editar sus propiedades.</div>
                ) : (
                  <div className="space-y-3 text-sm">
                    <div className="flex items-center justify-between">
                      <span className="text-gray-500">Tipo</span>
                      <span className="font-medium">{SHAPE_TYPES[selected.type].label}</span>
                    </div>
                    <div>
                      <label className="block text-gray-500">Etiqueta</label>
                      <input className="mt-1 w-full rounded-xl border px-3 py-2"
                             value={selected.label}
                             onChange={(e) => updateShape(selected.id, { label: e.target.value })} />
                    </div>
                    <div className="grid grid-cols-2 gap-2">
                      <div>
                        <label className="block text-gray-500">Ancho ({UNIT_META[unit].label})</label>
                        <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                               min={unit === "m" ? 0.05 : 5} step={unit === "m" ? 0.05 : 1}
                               value={Number(UNIT_META[unit].fromBase(selected.w / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                               onChange={(e) => updateShape(selected.id, { w: UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM })} />
                      </div>
                      <div>
                        <label className="block text-gray-500">Alto ({UNIT_META[unit].label})</label>
                        <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                               min={unit === "m" ? 0.05 : 5} step={unit === "m" ? 0.05 : 1}
                               value={Number(UNIT_META[unit].fromBase(selected.h / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                               onChange={(e) => updateShape(selected.id, { h: UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM })} />
                      </div>
                    </div>
                    <div className="grid grid-cols-2 gap-2">
                      <div>
                        <label className="block text-gray-500">X ({UNIT_META[unit].label})</label>
                        <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                               value={Number(UNIT_META[unit].fromBase(selected.x / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                               onChange={(e) => updateShape(selected.id, { x: Math.round((UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM) / gridStepInPx) * gridStepInPx })} />
                      </div>
                      <div>
                        <label className="block text-gray-500">Y ({UNIT_META[unit].label})</label>
                        <input type="number" className="mt-1 w-full rounded-xl border px-3 py-2"
                               value={Number(UNIT_META[unit].fromBase(selected.y / scalePxPerM)).toFixed(unit === "m" ? 2 : 0)}
                               onChange={(e) => updateShape(selected.id, { y: Math.round((UNIT_META[unit].toBase(Number(e.target.value)) * scalePxPerM) / gridStepInPx) * gridStepInPx })} />
                      </div>
                    </div>
                    <div className="grid grid-cols-2 gap-2 items-center">
                      <div>
                        <label className="block text-gray-500">Color</label>
                        <input type="color" className="mt-1 h-10 w-full rounded-xl border"
                               value={selected.fill}
                               onChange={(e) => updateShape(selected.id, { fill: e.target.value })} />
                      </div>
                      <div>
                        <label className="block text-gray-500">Opacidad</label>
                        <input type="range" min={0.2} max={1} step={0.05} className="mt-1 w-full"
                               value={selected.opacity}
                               onChange={(e) => updateShape(selected.id, { opacity: Number(e.target.value) })} />
                      </div>
                    </div>
                    <button onClick={deleteSelected} className="w-full mt-2 px-3 py-2 rounded-xl bg-red-50 text-red-700 border border-red-200 hover:bg-red-100">Eliminar figura</button>
                  </div>
                )}
              </Section>

              <Section title="Atajos útiles">
                <ul className="text-sm text-gray-600 list-disc pl-5 space-y-1">
                  <li><kbd className="px-1 border rounded">Shift + arrastrar</kbd> mueve el lienzo</li>
                  <li>Activa \"Ajustar a cuadrícula\" para precisión</li>
                </ul>
              </Section>
            </div>

            <div className="relative overflow-hidden">
              <div ref={canvasRef} className="absolute inset-0" style={gridBackground} onMouseDown={onMouseDownCanvas}>
                <div className="absolute" style={{ transform: `translate(${pan.x}px, ${pan.y}px)` }}>
                  {shapes.map((sh) => (
                    <Shape
                      key={sh.id}
                      shape={sh}
                      selected={selectedId === sh.id}
                      unitLabel={UNIT_META[unit].label}
                      sizePxToUnit={(px) => UNIT_META[unit].fromBase(px / scalePxPerM)}
                      onMouseDown={(e, mode) => onMouseDownShape(e, sh.id, mode)}  /* FIX: pasar el id */
                    />
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
